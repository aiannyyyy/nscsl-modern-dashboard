const oracledb = require('oracledb');
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

// ============================================================================
// CONFIGURATION
// ============================================================================

const REPORT_CONFIG = {
    CRYSTAL_REPORTS_DIR: path.join(__dirname, '..', 'crystal_reports'),
    OUTPUT_DIR: path.join(__dirname, '..', 'reports'),
    TEMP_DIR: path.join(__dirname, '..', 'temp'),
    REPORT_TEMPLATE: 'nsf_performance.rpt',
};

// Ensure directories exist
[REPORT_CONFIG.OUTPUT_DIR, REPORT_CONFIG.TEMP_DIR].forEach(dir => {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
});

// ============================================================================
// CRYSTAL REPORTS INTEGRATION (VB.NET Executable)
// ============================================================================

console.log('‚úÖ Crystal Reports integration using VB.NET executable');

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Generate unique request ID for tracking
 */
function generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
}

/**
 * Format date for display
 */
function formatDate(date) {
    if (!date) return 'N/A';
    const d = new Date(date);
    return d.toISOString().split('T')[0];
}

/**
 * Generate report using Crystal Reports VB.NET executable
 */
async function generateCrystalReportPDF(submid, dateFrom, dateTo, facilityName = '') {
    try {
        const fileName = `nsf_performance_${submid}_${dateFrom.replace(/-/g, '')}_${dateTo.replace(/-/g, '')}.pdf`;
        
        // VB.NET executable creates reports in its own Reports subfolder
        const exeDir = path.join(__dirname, '..', '..', 'CrystalReportExporter');
        const exePath = path.join(exeDir, 'CrystalReportExporter.exe');
        const reportOutputPath = path.join(exeDir, 'Reports', fileName);
        
        // Final destination in our reports folder
        const finalOutputPath = path.join(REPORT_CONFIG.OUTPUT_DIR, fileName);

        console.log('üìÑ Crystal Report Configuration:');
        console.log('   Executable:', exePath);
        console.log('   VB.NET Output:', reportOutputPath);
        console.log('   Final Output:', finalOutputPath);
        console.log('   SUBMID:', submid);
        console.log('   Date Range:', dateFrom, 'to', dateTo);
        console.log('   Facility:', facilityName);

        // Check if executable exists
        if (!fs.existsSync(exePath)) {
            throw new Error(`Crystal Reports executable not found: ${exePath}\nPlease ensure CrystalReportExporter.exe is in: ${exeDir}`);
        }

        // Check if template exists
        const templatePath = path.join(exeDir, 'Reports', 'nsf_performance.rpt');
        if (!fs.existsSync(templatePath)) {
            throw new Error(`Crystal Reports template not found: ${templatePath}`);
        }

        // Build command - VB.NET expects: GenerateReport.exe <Submid> <DateFrom> <DateTo>
        const command = `"${exePath}" ${submid} ${dateFrom} ${dateTo}`;
        
        console.log('üöÄ Executing Crystal Reports VB.NET Generator...');
        console.log('   Command:', command);
        console.log('   Working Directory:', exeDir);

        // Execute the VB.NET program
        const { stdout, stderr } = await execPromise(command, {
            cwd: exeDir,
            timeout: 180000, // 3 minutes
            maxBuffer: 10 * 1024 * 1024, // 10MB buffer for output
            windowsHide: true // Don't show console window
        });

        // Log output from VB.NET executable
        if (stdout) {
            console.log('üìã VB.NET Crystal Reports Output:');
            stdout.split('\n').forEach(line => {
                if (line.trim()) console.log('   ', line.trim());
            });
        }

        if (stderr) {
            console.warn('‚ö†Ô∏è VB.NET Warnings/Errors:');
            stderr.split('\n').forEach(line => {
                if (line.trim()) console.warn('   ', line.trim());
            });
        }

        // Check if PDF was created by VB.NET
        if (!fs.existsSync(reportOutputPath)) {
            throw new Error(`PDF generation failed - VB.NET executable did not create file: ${reportOutputPath}\n\nVB.NET Output:\n${stdout}\n\nErrors:\n${stderr}`);
        }

        const stats = fs.statSync(reportOutputPath);
        console.log(`‚úÖ Crystal Report generated by VB.NET: ${stats.size} bytes`);

        // Copy to final output directory
        if (reportOutputPath !== finalOutputPath) {
            fs.copyFileSync(reportOutputPath, finalOutputPath);
            console.log(`üìã Copied to final location: ${finalOutputPath}`);
        }

        return { filePath: finalOutputPath, fileName };

    } catch (error) {
        console.error('‚ùå Error executing Crystal Reports VB.NET generator:', error);
        
        // Provide helpful error messages
        if (error.code === 'ENOENT') {
            throw new Error('Crystal Reports executable not found. Please ensure CrystalReportExporter.exe is in backend/CrystalReportExporter/');
        }
        
        if (error.killed) {
            throw new Error('Crystal Reports generation timed out (exceeded 3 minutes). The report may be too large or complex.');
        }
        
        throw error;
    }
}

// ============================================================================
// CONTROLLER METHODS - DATA QUERIES
// ============================================================================

/**
 * Get NSF Performance data by county and date range
 */
exports.getNsfPerformance = async (req, res) => {
    let connection;
    const startTime = Date.now();

    try {
        // Validate required parameters
        const { county, dateFrom, dateTo } = req.query;

        if (!county || !dateFrom || !dateTo) {
            return res.status(400).json({
                success: false,
                error: 'Missing required query parameters: county, dateFrom, dateTo'
            });
        }

        const countyUpper = county.toUpperCase().trim();

        console.log('[NSF Performance Request]', { county: countyUpper, dateFrom, dateTo });

        // Get database connection from app.locals (set in server.js)
        const oraclePool = req.app.locals.oracleDb;
        
        if (!oraclePool) {
            return res.status(500).json({
                success: false,
                error: 'Database connection not available',
                message: 'Oracle connection pool is not initialized'
            });
        }

        connection = await oraclePool.getConnection();

        // SQL Query
        const query = `WITH filtered_sda AS (
                    SELECT *
                    FROM PHMSDS.SAMPLE_DEMOG_ARCHIVE
                    WHERE DTRECV >= TO_DATE(:dateFrom, 'YYYY-MM-DD')
                    AND DTRECV < TO_DATE(:dateTo, 'YYYY-MM-DD') + 1
                    AND LABNO NOT LIKE '_______8%'
                ),
                filtered_rpa AS (
                    SELECT *
                    FROM PHMSDS.REF_PROVIDER_ADDRESS
                    WHERE ADRS_TYPE = '1'
                    AND TRIM(COUNTY) = :county
                ),
                unsat_results AS (
                    SELECT DISTINCT LABNO, MNEMONIC
                    FROM PHMSDS.RESULT_ARCHIVE
                    WHERE MNEMONIC IN ('E100', 'E102', 'E108', 'E109', 'DE')
                ),
                full_results AS (
                    SELECT ra.LABNO, ra.MNEMONIC
                    FROM PHMSDS.RESULT_ARCHIVE ra
                ),
                joined_data AS (
                    SELECT
                        sda.SUBMID,
                        rpa.DESCR1 AS FACILITY_NAME,
                        sda.LABNO,
                        sda.BIRTHHOSP,
                        sda.SPECTYPE,
                        sda.AGECOLL,
                        sda.DTCOLL,
                        sda.DTRECV,
                        ur.MNEMONIC AS UNSAT_MNEMONIC,
                        fr.MNEMONIC AS ALL_MNEMONIC
                    FROM filtered_sda sda
                    JOIN filtered_rpa rpa ON rpa.PROVIDERID = sda.SUBMID
                    LEFT JOIN unsat_results ur ON sda.LABNO = ur.LABNO
                    LEFT JOIN full_results fr ON sda.LABNO = fr.LABNO
                )
                SELECT
                    SUBMID,
                    FACILITY_NAME,
                    COUNT(DISTINCT LABNO) AS TOTAL_SAMPLE_COUNT,
                    COUNT(DISTINCT CASE WHEN BIRTHHOSP = SUBMID THEN LABNO END) AS TOTAL_INBORN,
                    COUNT(DISTINCT CASE WHEN BIRTHHOSP = 'HOME' THEN LABNO END) AS TOTAL_HOMEBIRTH,
                    COUNT(DISTINCT CASE WHEN BIRTHHOSP NOT IN ('HOME', 'UNK') AND BIRTHHOSP <> SUBMID THEN LABNO END) AS TOTAL_HOB,
                    COUNT(DISTINCT CASE WHEN BIRTHHOSP = 'UNK' THEN LABNO END) AS TOTAL_UNKNOWN,

                    COUNT(DISTINCT CASE WHEN BIRTHHOSP IN ('HOME', 'UNK') OR (BIRTHHOSP NOT IN ('HOME', 'UNK') AND BIRTHHOSP <> SUBMID) THEN LABNO END) AS OUTBORN_TOTAL,

                    COUNT(DISTINCT CASE WHEN ALL_MNEMONIC = 'E100' THEN LABNO END) AS MISSING_INFORMATION,
                    COUNT(DISTINCT CASE WHEN ALL_MNEMONIC = 'E102' THEN LABNO END) AS LESS_THAN_24_HOURS,
                    COUNT(DISTINCT CASE WHEN ALL_MNEMONIC = 'E108' THEN LABNO END) AS INSUFFICIENT,
                    COUNT(DISTINCT CASE WHEN ALL_MNEMONIC = 'E109' THEN LABNO END) AS CONTAMINATED,
                    COUNT(DISTINCT CASE WHEN ALL_MNEMONIC = 'DE' THEN LABNO END) AS CONTAMINATED,

                    COUNT(DISTINCT CASE WHEN UNSAT_MNEMONIC IS NOT NULL THEN LABNO END) AS TOTAL_UNSAT_COUNT,

                    ROUND(
                        COUNT(DISTINCT CASE WHEN UNSAT_MNEMONIC IS NOT NULL THEN LABNO END) * 100.0
                        / NULLIF(COUNT(DISTINCT LABNO), 0),
                        2
                    ) AS TOTAL_UNSAT_RATE,

                    ROUND(AVG(CASE WHEN SPECTYPE IN (20, 87) THEN AGECOLL / 24 END), 2) AS AVE_AOC,
                    ROUND(AVG(DTRECV - DTCOLL), 2) AS TRANSIT_TIME,
                    ROUND(AVG(CASE WHEN BIRTHHOSP = SUBMID AND SPECTYPE IN (20, 87) THEN AGECOLL / 24 END), 2) AS INBORN_AVERAGE,
                    ROUND(AVG(CASE WHEN BIRTHHOSP <> SUBMID AND SPECTYPE IN (20, 87) THEN AGECOLL / 24 END), 2) AS OUTBORN_AVERAGE

                FROM joined_data
                GROUP BY SUBMID, FACILITY_NAME
                ORDER BY SUBMID, FACILITY_NAME`;

        const binds = {
            county: countyUpper,
            dateFrom,
            dateTo
        };

        console.log('[Bind Variables]', binds);

        // Execute query
        const result = await connection.execute(query, binds, {
            outFormat: oracledb.OUT_FORMAT_OBJECT,
            fetchArraySize: 1000,
            maxRows: 0
        });

        const executionTime = Date.now() - startTime;

        // Handle empty results
        if (!result.rows || result.rows.length === 0) {
            console.warn('[No Results Found]', binds);
            return res.json({
                success: true,
                message: "No data found for the specified criteria",
                data: [],
                executionTime: `${executionTime}ms`,
                recordCount: 0,
                filters: {
                    county: countyUpper,
                    dateFrom,
                    dateTo
                }
            });
        }

        console.log(`[Query Result] Returned ${result.rows.length} rows`);

        // Return successful response
        res.json({
            success: true,
            data: result.rows,
            executionTime: `${executionTime}ms`,
            recordCount: result.rows.length,
            filters: {
                county: countyUpper,
                dateFrom,
                dateTo
            }
        });

    } catch (err) {
        console.error('‚ùå Database error:', err);
        
        const executionTime = Date.now() - startTime;
        
        res.status(500).json({
            success: false,
            error: 'An error occurred while fetching NSF performance data',
            message: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error',
            executionTime: `${executionTime}ms`
        });
    } finally {
        if (connection) {
            try {
                await connection.close();
            } catch (closeErr) {
                console.error('‚ùå Error closing connection:', closeErr);
            }
        }
    }
};

/**
 * Get NSF Performance Lab Details by submid and date range
 */
exports.getNsfPerformanceLabDetails = async (req, res) => {
    let connection;
    const startTime = Date.now();

    try {
        // Validate required parameters
        const { submid, dateFrom, dateTo } = req.query;

        if (!submid || !dateFrom || !dateTo) {
            return res.status(400).json({
                success: false,
                error: 'Missing required query parameters: submid, dateFrom, dateTo'
            });
        }

        console.log('[Lab Details Request]', { submid, dateFrom, dateTo });

        // Get database connection from app.locals (set in server.js)
        const oraclePool = req.app.locals.oracleDb;
        
        if (!oraclePool) {
            return res.status(500).json({
                success: false,
                error: 'Database connection not available',
                message: 'Oracle connection pool is not initialized'
            });
        }

        connection = await oraclePool.getConnection();

        // SQL Query
        const query = `
       WITH COMBINED AS (
        SELECT /*+ MATERIALIZE */
        S."LABNO" AS LABNO,
        S."SUBMID" AS SUBMID,
        S."FNAME" AS FNAME,
        S."LNAME" AS LNAME,
        S."SPECTYPE" AS SPECTYPE,
        S."BIRTHHOSP" AS BIRTHHOSP,
        D."MNEMONIC" AS MNEMONIC,
        'DISORDER' AS SOURCE_TABLE
        FROM
        "PHMSDS"."DISORDER_ARCHIVE" D
        JOIN "PHMSDS"."SAMPLE_DEMOG_ARCHIVE" S
        ON D."LABNO" = S."LABNO"
        WHERE
        S."SUBMID" = :submid
        AND S."DTRECV" >= TO_DATE(:dateFrom, 'YYYY-MM-DD')
        AND S."DTRECV" < TO_DATE(:dateTo, 'YYYY-MM-DD') + 1
        AND S."LABNO" NOT LIKE '_______8%'
        UNION ALL
        SELECT /*+ MATERIALIZE */
        S."LABNO" AS LABNO,
        S."SUBMID" AS SUBMID,
        S."FNAME" AS FNAME,
        S."LNAME" AS LNAME,
        S."SPECTYPE" AS SPECTYPE,
        S."BIRTHHOSP" AS BIRTHHOSP,
        RSLT."MNEMONIC" AS MNEMONIC,
        'RESULT' AS SOURCE_TABLE
        FROM
        "PHMSDS"."RESULT_ARCHIVE" RSLT
        JOIN "PHMSDS"."SAMPLE_DEMOG_ARCHIVE" S
        ON RSLT."LABNO" = S."LABNO"
        WHERE
        S."SUBMID" = :submid
        AND S."DTRECV" >= TO_DATE(:dateFrom, 'YYYY-MM-DD')
        AND S."DTRECV" < TO_DATE(:dateTo, 'YYYY-MM-DD') + 1
        AND S."LABNO" NOT LIKE '_______8%'
        )
        SELECT
        LABNO,
        MAX(SUBMID) AS SUBMID,
        MAX(FNAME) AS FNAME,
        MAX(LNAME) AS LNAME,
        MAX(SPECTYPE) AS SPECTYPE,
        CASE 
        WHEN MAX(SPECTYPE) = 20 THEN 'Initial'
        WHEN MAX(SPECTYPE) IN (2, 3, 4) THEN 'Repeat'
        WHEN MAX(SPECTYPE) = 5 THEN 'Monitoring'
        WHEN MAX(SPECTYPE) = 87 THEN 'Unfit'
        ELSE 'Other'
        END AS SPECTYPE_LABEL,
        MAX(BIRTHHOSP) AS BIRTHHOSP,
        CASE 
        WHEN MAX(BIRTHHOSP) = TO_CHAR(MAX(SUBMID)) THEN 'INBORN'
        WHEN MAX(BIRTHHOSP) = 'HOME' THEN 'HOMEBIRTH'
        WHEN MAX(BIRTHHOSP) = 'UNK' THEN 'UNKNOWN'
        WHEN MAX(BIRTHHOSP) NOT IN ('HOME', 'UNK') 
        AND MAX(BIRTHHOSP) <> TO_CHAR(MAX(SUBMID)) THEN 'HOB'
        ELSE 'OTHER'
        END AS BIRTH_CATEGORY,
        CASE 
        WHEN MAX(CASE WHEN MNEMONIC NOT IN ('FA', '*FA', 'NFT', 'E106', 'NFTR', 'ABN') THEN 1 ELSE 0 END) = 0 
        THEN 'NORMAL'
        ELSE MAX(CASE 
        WHEN MNEMONIC = 'E100' THEN 'MISSING_INFORMATION'
        WHEN MNEMONIC = 'E102' THEN 'LESS_THAN_24_HOURS'
        WHEN MNEMONIC = 'E108' THEN 'INSUFFICIENT'
        WHEN MNEMONIC = 'E109' THEN 'CONTAMINATED'
        WHEN MNEMONIC = 'DE' THEN 'DATA_ERASURES'
        WHEN MNEMONIC = 'PRT' THEN 'PRETERM'
        ELSE NULL
        END)
        END AS ISSUE_DESCRIPTION
        FROM COMBINED
        GROUP BY LABNO
         ORDER BY LABNO ASC`;

        const binds = {
            submid,
            dateFrom,
            dateTo
        };

        // Execute query
        const result = await connection.execute(query, binds, {
            outFormat: oracledb.OUT_FORMAT_OBJECT,
            fetchArraySize: 1000,
            maxRows: 0
        });

        const executionTime = Date.now() - startTime;

        console.log(`[Lab Details] Query returned ${result.rows.length} rows`);

        // Handle empty results
        if (!result.rows || result.rows.length === 0) {
            return res.json({
                success: true,
                message: "No lab details found for the specified criteria",
                data: [],
                executionTime: `${executionTime}ms`,
                recordCount: 0,
                filters: {
                    submid,
                    dateFrom,
                    dateTo
                }
            });
        }

        // Return successful response
        res.json({
            success: true,
            data: result.rows,
            executionTime: `${executionTime}ms`,
            recordCount: result.rows.length,
            filters: {
                submid,
                dateFrom,
                dateTo
            }
        });

    } catch (err) {
        console.error('‚ùå Database error:', err);
        
        const executionTime = Date.now() - startTime;
        
        res.status(500).json({
            success: false,
            error: 'An error occurred while fetching lab details',
            message: process.env.NODE_ENV === 'development' ? err.message : 'Internal server error',
            executionTime: `${executionTime}ms`
        });
    } finally {
        if (connection) {
            try {
                await connection.close();
            } catch (closeErr) {
                console.error('‚ùå Error closing connection:', closeErr);
            }
        }
    }
};

// ============================================================================
// CONTROLLER METHODS - CRYSTAL REPORTS GENERATION
// ============================================================================

/**
 * Generate NSF Performance Report using Crystal Reports
 */
exports.generateNsfReport = async (req, res) => {
    const { submid, dateFrom, dateTo } = req.query;
    const requestId = generateRequestId();
    let connection;
    
    console.log(`[${requestId}] ============================================`);
    console.log(`[${requestId}] Crystal Reports PDF Generation Request`);
    console.log(`[${requestId}] SUBMID: ${submid}`);
    console.log(`[${requestId}] Date Range: ${dateFrom} to ${dateTo}`);
    console.log(`[${requestId}] ============================================`);

    try {
        // Validate required parameters
        if (!submid || !dateFrom || !dateTo) {
            console.log(`[${requestId}] Missing parameters`);
            return res.status(400).json({ 
                error: 'Missing required parameters: submid, dateFrom, dateTo',
                requestId: requestId
            });
        }

        // Validate date format
        const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
        if (!dateRegex.test(dateFrom) || !dateRegex.test(dateTo)) {
            console.log(`[${requestId}] Invalid date format`);
            return res.status(400).json({ 
                error: 'Invalid date format. Use YYYY-MM-DD format.',
                requestId: requestId
            });
        }

        // Validate date range
        const fromDate = new Date(dateFrom);
        const toDate = new Date(dateTo);
        if (fromDate > toDate) {
            console.log(`[${requestId}] Invalid date range`);
            return res.status(400).json({ 
                error: 'Start date cannot be after end date.',
                requestId: requestId
            });
        }

        // Get facility name from database
        const oraclePool = req.app.locals.oracleDb;
        if (!oraclePool) {
            return res.status(500).json({
                error: 'Database connection not available',
                requestId: requestId
            });
        }

        connection = await oraclePool.getConnection();
        console.log(`[${requestId}] Database connection established`);

        // Fetch facility name
        const facilityQuery = `
            SELECT DESCR1 AS FACILITY_NAME
            FROM PHMSDS.REF_PROVIDER_ADDRESS
            WHERE PROVIDERID = :submid AND ADRS_TYPE = '1'
        `;

        const facilityResult = await connection.execute(facilityQuery, { submid }, {
            outFormat: oracledb.OUT_FORMAT_OBJECT
        });

        const facilityName = facilityResult.rows?.[0]?.FACILITY_NAME || '';
        console.log(`[${requestId}] Facility Name: ${facilityName}`);

        // Generate Crystal Report
        console.log(`[${requestId}] Calling Crystal Reports generator...`);
        const { filePath, fileName } = await generateCrystalReportPDF(
            submid,
            dateFrom,
            dateTo,
            facilityName
        );

        console.log(`[${requestId}] Crystal Report generated: ${fileName}`);

        // Check if file exists and get stats
        if (!fs.existsSync(filePath)) {
            throw new Error('PDF generation failed - file not created');
        }

        const stats = fs.statSync(filePath);
        console.log(`[${requestId}] PDF size: ${stats.size} bytes`);

        // Stream the PDF to response
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `inline; filename="${fileName}"`);
        res.setHeader('Content-Length', stats.size);
        res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
        res.setHeader('X-Request-ID', requestId);
        res.setHeader('X-Report-Generator', 'Crystal Reports');
        res.setHeader('X-File-Size', stats.size.toString());

        const fileStream = fs.createReadStream(filePath);
        fileStream.pipe(res);

        fileStream.on('end', () => {
            console.log(`[${requestId}] ‚úÖ PDF streamed successfully`);
            // Optional: Clean up file after streaming
            // setTimeout(() => fs.unlinkSync(filePath), 60000);
        });

        fileStream.on('error', (error) => {
            console.error(`[${requestId}] ‚ùå Stream error:`, error);
            if (!res.headersSent) {
                res.status(500).json({
                    error: 'Error streaming PDF',
                    requestId: requestId
                });
            }
        });

    } catch (error) {
        console.error(`[${requestId}] ‚ùå Error:`, error);
        console.error(`[${requestId}] ‚ùå Error Message:`, error.message);
        console.error(`[${requestId}] ‚ùå Error Stack:`, error.stack);
        
        if (!res.headersSent) {
            res.status(500).json({ 
                error: 'Internal server error during PDF generation',
                details: error.message,
                stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
                requestId: requestId
            });
        }
    } finally {
        if (connection) {
            try {
                await connection.close();
                console.log(`[${requestId}] Database connection closed`);
            } catch (closeErr) {
                console.error(`[${requestId}] Error closing connection:`, closeErr);
            }
        }
    }
};

/**
 * List available report files
 */
exports.listReports = async (req, res) => {
    try {
        if (!fs.existsSync(REPORT_CONFIG.OUTPUT_DIR)) {
            return res.status(404).json({ 
                error: 'Reports directory not found',
                expectedPath: REPORT_CONFIG.OUTPUT_DIR
            });
        }
        
        const files = fs.readdirSync(REPORT_CONFIG.OUTPUT_DIR);
        const fileDetails = files
            .filter(file => file.endsWith('.pdf'))
            .map(file => {
                const filePath = path.join(REPORT_CONFIG.OUTPUT_DIR, file);
                const stats = fs.statSync(filePath);
                return {
                    name: file,
                    size: stats.size,
                    created: stats.birthtime,
                    modified: stats.mtime
                };
            })
            .sort((a, b) => b.modified - a.modified);
        
        res.json({
            reportsDirectory: REPORT_CONFIG.OUTPUT_DIR,
            totalFiles: fileDetails.length,
            files: fileDetails,
            generator: 'Crystal Reports',
            timestamp: new Date().toISOString()
        });
        
    } catch (error) {
        res.status(500).json({ 
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
};

/**
 * Serve a specific report file
 */
exports.serveReport = async (req, res) => {
    const requestId = generateRequestId();
    const fileName = req.params.filename;
    
    console.log(`[${requestId}] Serving report: ${fileName}`);
    
    try {
        const filePath = path.join(REPORT_CONFIG.OUTPUT_DIR, fileName);
        
        // Security check - prevent directory traversal
        const resolvedPath = path.resolve(filePath);
        const resolvedDir = path.resolve(REPORT_CONFIG.OUTPUT_DIR);
        
        if (!resolvedPath.startsWith(resolvedDir)) {
            console.warn(`[${requestId}] Security violation: attempted directory traversal`);
            return res.status(403).json({ error: 'Access denied' });
        }
        
        // Check file exists
        if (!fs.existsSync(filePath)) {
            return res.status(404).json({ error: 'File not found' });
        }
        
        // Only allow PDF files
        if (!fileName.toLowerCase().endsWith('.pdf')) {
            return res.status(400).json({ error: 'Only PDF files allowed' });
        }
        
        const stats = fs.statSync(filePath);
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `inline; filename="${fileName}"`);
        res.setHeader('Content-Length', stats.size);
        res.setHeader('X-Report-Generator', 'Crystal Reports');
        
        const fileStream = fs.createReadStream(filePath);
        fileStream.pipe(res);
        
        console.log(`[${requestId}] ‚úÖ Report served successfully`);
        
    } catch (error) {
        console.error(`[${requestId}] ‚ùå Error:`, error);
        res.status(500).json({ error: 'Internal server error' });
    }
};

/**
 * Health check for Crystal Reports system
 * ‚ö†Ô∏è UPDATED: Removed Edge.js references, now reports VB.NET executable status
 */
exports.reportSystemHealth = async (req, res) => {
    try {
        console.log('üè• Running Crystal Reports health check...');
        
        // Check directories
        let outputDirExists = false;
        let tempDirExists = false;
        let exeDirExists = false;
        let exeExists = false;
        let templateExists = false;
        let exeReportsDirExists = false;
        
        const exeDir = path.join(__dirname, '..', '..', 'CrystalReportExporter');
        const exePath = path.join(exeDir, 'CrystalReportExporter.exe');
        const templatePath = path.join(exeDir, 'Reports', 'nsf_performance.rpt');
        const exeReportsDir = path.join(exeDir, 'Reports');
        
        try {
            outputDirExists = fs.existsSync(REPORT_CONFIG.OUTPUT_DIR);
            tempDirExists = fs.existsSync(REPORT_CONFIG.TEMP_DIR);
            exeDirExists = fs.existsSync(exeDir);
            exeExists = fs.existsSync(exePath);
            templateExists = fs.existsSync(templatePath);
            exeReportsDirExists = fs.existsSync(exeReportsDir);
            
            console.log('üìÅ Directory Check:', {
                output: outputDirExists,
                temp: tempDirExists,
                exeDir: exeDirExists,
                exe: exeExists,
                template: templateExists,
                exeReportsDir: exeReportsDirExists
            });
        } catch (dirError) {
            console.error('‚ö†Ô∏è Directory check error:', dirError.message);
        }
        
        // Get recent files
        let recentFiles = [];
        try {
            if (outputDirExists) {
                const files = fs.readdirSync(REPORT_CONFIG.OUTPUT_DIR);
                recentFiles = files.filter(f => f.endsWith('.pdf')).slice(0, 5);
            }
        } catch (filesError) {
            console.error('‚ö†Ô∏è Files check error:', filesError.message);
        }
        
        console.log('üîß VB.NET Executable Status:', exeExists ? 'Available' : 'Not Available');
        
        // Determine overall status
        let status = 'ok';
        const issues = [];
        
        if (!exeExists) {
            status = 'error';
            issues.push(`VB.NET executable not found: ${exePath}`);
            issues.push('Please ensure CrystalReportExporter.exe is in backend/CrystalReportExporter/');
        }
        
        if (!outputDirExists) {
            status = 'error';
            issues.push(`Output directory not found: ${REPORT_CONFIG.OUTPUT_DIR}`);
        }
        
        if (!exeDirExists) {
            status = 'error';
            issues.push(`CrystalReportExporter directory not found: ${exeDir}`);
        }
        
        if (!templateExists) {
            status = 'error';
            issues.push(`Crystal Reports template not found: ${templatePath}`);
        }

        if (!exeReportsDirExists) {
            status = 'error';
            issues.push(`VB.NET Reports directory not found: ${exeReportsDir}`);
        }
        
        // ‚ö†Ô∏è KEY CHANGE: Use "vbnet_executable" instead of "edgeJsIntegration"
        const health = {
            status: status,
            reportGenerator: 'Crystal Reports (VB.NET Executable)',
            vbnetExecutable: exeExists ? 'available' : 'not available',  // Changed from edgeJsIntegration
            directories: {
                output: {
                    path: REPORT_CONFIG.OUTPUT_DIR,
                    exists: outputDirExists
                },
                temp: {
                    path: REPORT_CONFIG.TEMP_DIR,
                    exists: tempDirExists
                },
                crystalReportExporter: {
                    path: exeDir,
                    exists: exeDirExists
                },
                vbnetReports: {
                    path: exeReportsDir,
                    exists: exeReportsDirExists
                }
            },
            executable: {
                path: exePath,
                exists: exeExists,
                name: 'CrystalReportExporter.exe'
            },
            template: {
                name: 'nsf_performance.rpt',
                path: templatePath,
                exists: templateExists
            },
            recentFiles: recentFiles,
            issues: issues.length > 0 ? issues : null,
            configuration: REPORT_CONFIG,
            timestamp: new Date().toISOString()
        };
        
        console.log('‚úÖ Health Check Result:', { status, issuesCount: issues.length });
        
        res.status(200).json(health);
        
    } catch (error) {
        console.error('‚ùå Health check critical error:', error);
        
        res.status(200).json({
            status: 'error',
            reportGenerator: 'Crystal Reports (VB.NET Executable)',
            vbnetExecutable: 'unknown',  // Changed from edgeJsIntegration
            error: error.message,
            stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
            timestamp: new Date().toISOString()
        });
    }
};